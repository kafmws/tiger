##### 本章难度突升
反复阅读 chap6, chap7，其实还是我太弱。。

#### UNDO
- 完成翻译函数
- 检查数组下标及解引用时引用判空（pass）
- 确认Eseq、expList的优先级高于其余stm
- 此处有一个假想，目前的中间代码，对于选择结构生成true和false，和end三个label，
而实际上可以把一个分支的代码放在test下，从而省略一个标签。
- 翻译时尽可能将局部变量注册到栈帧，对寄存器分配是否有好处？

## Tips

#### Frame模块
- Frame模块是对栈帧的抽象描述，每一个栈帧对象描述了一个函数的栈帧布局，主要包括
  - 函数参数的位置及访问方式（首选栈帧/首选寄存器）
  - 为局部变量分配的空间（记录个数）
  - 保存寄存器的位置
等等，并且实现为变量分配空间的接口（分配的同时维护栈帧）
- 函数参数由 caller push 到栈上，由 ebx + offset 向上偏移进行访问
- 当前栈帧内的局部变量由 ebx - offset 向下访问
- 外层的局部变量的访问：追溯静态链直到到达外层变量所在层（得到该层帧指针），由该帧指针通过 F_access （Tr_access中）偏移访问该变量。

#### 静态链和动态链
动态链即保存的ebp，是调用函数栈每个栈帧的栈指针

静态链，程序中==静态的嵌套关系==，每当调用函数f时，传递给f一个指针，该指针为静态包含f的函数的帧指针
```
function f(){
    function g(){
        h();
    }
    function h(){

    }
}
```
如上，g调用h，h当前栈帧中动态链为g栈帧的ebp（帧指针），
而静态链为g栈帧中保存的f的栈帧帧指针（由g调用h时传递给h）。

#### 修改了 break 语句是否在循环内的判定
chap5使用静态全局变量 forOrWhile（栈指针）及 局部变量 oldForOrWhile（栈） 形成的栈，（或者说抽象链表）
栈顶元素始终指向当前所处的循环语句，
现在将保存循环语句指针改为保存循环的 done 标号，以便于实现 break 语句。
并且此策略可省去在 transExp, transDec 函数的中传递 done 作为参数。

另一处优化，transExp 中的 for 和 while 中使用同一个 old_doneLabel 变量，而非各自声明两个（也许不会被优化为同一个变量，可能是 overthink）

另一种优点，可以识别任何处于循环中的语句，例如赋值语句。

#### 保护循环变量的两种方法
1. 可以将循环变量注册为 \<loop-variable-name\>，若赋值语句在循环中若发现未声明变量则加尖括号检查，反馈相应信息。（此方法无法引用循环变量）
2. 在注册信息中添加常量标志（有利于扩展常量支持）

#### 关于左值及引用的翻译
由于 Tiger 支持引用，任何时候数组及记录类型变量都以引用形式存放
如以下类型的值
```
/* tiger */
let
    type list = {e:int, next:list}
    var l := list{e=1, next=nil}
in
    l.next := l
end
```
其在内存中如此存放

```ditaa {cmd="true" args=["-E"] hide=true}
+------------+------------+
|    e(1)    | next(0xA)  |
+------------+------------+
^
|
0xA
```
我们在翻译普通变量、下标和域时一律可以使用
MEM(BINOP(ADDR ~l~ , OFFSET~next~))，本例中其值为 0xA

而对于`Passcal`及`C`这样将结构体类型表现为一大块值的语言
如
```C
struct A{
    int a;
    int b;
};

struct B{
    int c;
    struct A a;
};

B b = (struct B){1, (struct A){2, 3}};
```
其存放布局为
```ditaa {cmd="true" args=["-E"] hide=true}
            0xB
             |
             v
+------------+------------+------------+
|    c(1)    |   a.a(2)   |   a.b(3)   |
+------------+------------+------------+
^            |                         |
|            \------------v------------/
0xA                      b.a
```
当我们翻译变量`b.a`时，应注意仅使用 BINOP(ADDR ~b~ , OFFSET~a~)，这样得到的是`&b.a`(0xB)，
仍为一个左值（地址），这样我们可以进一步翻译`b.a.a`(在该地址上继续偏移)
如果使用了 MEM(BINOP(ADDR ~b~ , OFFSET~a~))，则得到的是 向0xB开始的8个字节进行存或取 操作，无法继续作为左值进行下标及字段的索引（改变操作的地址及操作的字长），除非再褪去MEM层

而对于 Tiger 等语言，因为以（指针/引用）的方式保存复合类型，所以在地址计算后总是可以、并且需要使用 MEM 访存。

#### 关于中间表示
对于特定的指令集，指令语句可以进行某些简化。
而对于中间表示来说，它应当与任何指令集无关。
因此不应当省略某些细节。如：选择结构的真链和假链，不应当省略。


### 吐槽
代码命名规则较混乱，如枚举名，一会儿大写一会小写。。
