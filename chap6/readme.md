##### 本章难度突升
反复阅读 chap6, chap7，其实还是我太弱。。

#### UNDO
- 完成翻译函数
- 检查数组下标及解引用时引用判空（pass）
- 确认Eseq、expList的优先级高于其余stm
- 此处有一个假想，目前的中间代码，对于选择结构生成true和false，和end三个label，
而实际上可以把一个分支的代码放在test下，从而省略一个标签。

## Tips

#### Frame模块
- Frame模块是对栈帧的抽象描述，每一个栈帧对象描述了一个函数的栈帧布局，主要包括
  - 函数参数的位置及访问方式（首选栈帧/首选寄存器）
  - 为局部变量分配的空间（记录个数）
  - 保存寄存器的位置
等等，并且实现为变量分配空间的接口（分配的同时维护栈帧）
- 函数参数由 caller push 到栈上，由 ebx + offset 向上偏移进行访问
- 当前栈帧内的局部变量由 ebx - offset 向下访问
- 外层的局部变量的访问：追溯静态链直到到达外层变量所在层（得到该层帧指针），由该帧指针通过 F_access （Tr_access中）偏移访问该变量。

#### 静态链和动态链
动态链即保存的ebp，是调用函数栈每个栈帧的栈指针

静态链，程序中==静态的嵌套关系==，每当调用函数f时，传递给f一个指针，该指针为静态包含f的函数的帧指针
```
function f(){
    function g(){
        h();
    }
    function h(){

    }
}
```
如上，g调用h，h当前栈帧中动态链为g栈帧的ebp（帧指针），
而静态链为g栈帧中保存的f的栈帧帧指针（由g调用h时传递给h）。

#### 关于左值及引用的翻译
由于 Tiger 支持引用，任何时候数组及记录类型变量都以引用形式存放
如以下类型的值
```
/* tiger */
let
    type list = {e:int, next:list}
    var l := list{e=1, next=nil}
in
    l.next := l
end
```
其在内存中如此存放

```ditaa {cmd="true" args=["-E"] hide=true}
+------------+------------+
|    e(1)    | next(0xA)  |
+------------+------------+
^
|
0xA
```
我们在翻译普通变量、下标和域时一律可以使用
MEM(BINOP(ADDR ~l~ , OFFSET~next~))，本例中其值为 0xA

而对于`Passcal`及`C`这样将结构体类型表现为一大块值的语言
如
```C
struct A{
    int a;
    int b;
};

struct B{
    int c;
    struct A a;
};

B b = (struct B){1, (struct A){2, 3}};
```
其存放布局为
```ditaa {cmd="true" args=["-E"] hide=true}
            0xB
             |
             v
+------------+------------+------------+
|    c(1)    |   a.a(2)   |   a.b(3)   |
+------------+------------+------------+
^            |                         |
|            \------------v------------/
0xA                      b.a
```
当我们翻译变量`b.a`时，应注意仅使用 BINOP(ADDR ~b~ , OFFSET~a~)，这样得到的是`&b.a`(0xB)，
仍为一个左值（地址），这样我们可以进一步翻译`b.a.a`(在该地址上继续偏移)
如果使用了 MEM(BINOP(ADDR ~b~ , OFFSET~a~))，则得到的是 向0xB开始的8个字节进行存或取 操作，无法继续作为左值进行下标及字段的索引（改变操作的地址及操作的字长），除非再褪去MEM层

而对于 Tiger 等语言，因为以（指针/引用）的方式保存复合类型，所以在地址计算后总是可以、并且需要使用 MEM 访存。

### 吐槽
代码命名规则较混乱，如枚举名，一会儿大写一会小写。。
