### 如何判定break语句属于哪个循环
定义静态全局变量，进入for/while语句时记录当前exp，退出时置NULL，处理break语句时该变量即为其所在循环。

### 如何检查for中的循环变量在循环体中未被赋值
原理同上。若赋值语句处于for循环中，检查左值是否为循环变量。

### 关于错误信息的输出
由于所有的类型都是通过 Ty_ty 来确定的（比较指针），
每一个名字与其实体\<name, Ty_ty\>都是唯一的，
因此利用 S_dump/TAB_dump 通过 Ty_ty 查找出符号名字，
在报错信息中输出，给用户更友好的体验。

并在初始环境(tyEnv、idEnv)中添加表示记录类型本身、数组类型本身的两个类型、表示函数的E_enventry，
以及对应NULL的未知类型、未知名字，
便于配合TYPE_CHECK、NAME_CHECK等宏给出较友好的错误信息。

### 类型别名的处理
可以使用一个 type 来定义另一个 type，新产生的 type 的类型为 Ty_name，即它只是另一个类型的名字。
在对 Ty_ty 进行比较时，将追溯到其真正的类型进行比较。
而在其余使用中，使用声明类型进行处理，以便错误信息与声明类型保持一致。

另一种“鸵鸟策略”是在处理类型声明时，将所有别名都绑定到真实定义的 Ty_ty，这样别名类型就名存实亡。
而无法通过 Ty_ty 得到作为声明类型的类型别名。


### 小坑
在 parsetest.c 中使用了 EM_anyErrors，死活找不到符号
最后用 nm 命令查看符号表，才发现 errormsg.c 中定义的是 anyErrors，errormsg.h 声明的是 EM_.. :)
